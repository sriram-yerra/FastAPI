1. Uses async def to define asynchronous functions

Meaning:
You declare a function as async so Python knows it can pause and resume it.

async def get_data():
    ...


In FastAPI, this is used for endpoints:

@app.get("/users")
async def read_users():
    return {"users": []}


ğŸ‘‰ This tells FastAPI:
â€œThis function may wait for something (DB, API, file), so donâ€™t block the server.â€

âœ… 2. Uses await to pause until a task finishes without blocking others

This is the most important part.

data = await fetch_from_api()


What happens:

Step	What actually happens
await is hit	Function pauses
While waiting	Server handles other requests
When ready	Function resumes from same line

ğŸ’¡ Youâ€™re not freezing the program â€” you're just saying:

â€œIâ€™ll wait, but others can work.â€

âœ… 3. Great for I/O-bound work

Async shines when your code is waiting, not computing.

Examples in backend apps:

Task	Why async helps
ğŸŒ API calls	Network delay
ğŸ—„ Database queries	DB response time
ğŸ“‚ File reading	Disk I/O delay
â˜ Cloud storage	Remote latency

âŒ Not useful for:

Image processing

AI inference

Heavy math
These are CPU-bound (need multiprocessing, not async).

âœ… 4. Runs concurrently, but not necessarily parallel

This is where people get confused.

Term	Meaning
Concurrent	Multiple tasks in progress (taking turns)
Parallel	Tasks run at the exact same time on multiple CPU cores

Async = concurrency, not guaranteed parallelism.

Imagine:

Task A: Waiting for DB
Task B: Waiting for API
Task C: Waiting for file


The CPU isnâ€™t doing much â€” so async lets them all wait together, instead of one by one.